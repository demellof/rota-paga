{
  "projectName": "Refatoração Rota Pagã",
  "goal": "Migrar sistematicamente todas as funcionalidades do 'Portal Grimório' legado para a nova arquitetura front-end 'Rota Pagã'. O objetivo é criar uma aplicação moderna, reativa e de fácil manutenção, utilizando React, TypeScript e TanStack Query. A migração da funcionalidade 'O Panteão' serve como o blueprint definitivo para todas as migrações futuras.",
  "architecture": {
    "description": "A arquitetura é baseada em uma clara separação de responsabilidades em três camadas principais.",
    "layers": [
      {
        "name": "UI Layer (Pages/Components)",
        "path": "src/pages/*.tsx",
        "responsibility": "Renderizar a interface do usuário. É totalmente desacoplada da lógica de busca ou mutação de dados. Utiliza os hooks da camada de Hooks para obter dados e funções para interagir com o estado do servidor.",
        "exampleFile": "src/pages/PanteaoPage.tsx"
      },
      {
        "name": "Hooks Layer (Custom Hooks)",
        "path": "src/hooks/*.ts",
        "responsibility": "Gerenciar o estado do servidor usando TanStack Query. Hooks com 'useQuery' para buscar dados e hooks com 'useMutation' para modificar dados. Eles servem como a ponte entre a UI e a Camada de Serviço.",
        "exampleFiles": ["src/hooks/useArchetypes.ts", "src/hooks/useToggleFavoriteArchetype.ts"]
      },
      {
        "name": "Service Layer",
        "path": "src/services/*.ts",
        "responsibility": "Abstrair a comunicação com o backend (Firestore). Contém funções assíncronas que realizam as chamadas de API reais. Esta camada não sabe nada sobre React ou TanStack Query.",
        "exampleFile": "src/services/firestore.ts"
      }
    ]
  },
  "keyPatterns": {
    "dataFetching": {
      "title": "Padrão de Busca de Dados (useQuery)",
      "description": "Para buscar dados, criamos um hook customizado que encapsula o `useQuery` do TanStack Query.",
      "steps": [
        "1. Definir uma `queryKey` única para identificar os dados no cache (ex: `['archetypes']`).",
        "2. Criar uma `queryFn`, que é uma função assíncrona (geralmente da Camada de Serviço) que busca os dados.",
        "3. O componente de UI usa o hook customizado para acessar `data`, `isLoading`, e `error`."
      ],
      "codeSnippet": "/* src/hooks/useArchetypes.ts */\n\nimport { useQuery } from '@tanstack/react-query';\nimport { fetchArchetypesFromService } from '../services/api'; // Exemplo\n\nexport const useArchetypes = () => {\n  return useQuery({\n    queryKey: ['archetypes'],\n    queryFn: fetchArchetypesFromService,\n  });\n};"
    },
    "dataMutation": {
      "title": "Padrão de Mutação e Revalidação Automática (useMutation)",
      "description": "Este é o padrão mais crucial. Ele garante que a UI seja atualizada automaticamente após uma modificação de dados no servidor.",
      "steps": [
        "1. Criar um hook customizado que encapsula o `useMutation`.",
        "2. A `mutationFn` recebe os parâmetros necessários e chama a função apropriada da Camada de Serviço para atualizar os dados.",
        "3. No callback `onSuccess` da mutação, usamos `queryClient.invalidateQueries`.",
        "4. A invalidação informa ao TanStack Query que os dados associados a uma `queryKey` específica (ex: `['userProfile']`) estão desatualizados.",
        "5. O TanStack Query automaticamente re-executa a query correspondente, buscando os dados frescos.",
        "6. A UI, que usa o hook daquela query, re-renderiza com os novos dados, sem nenhuma intervenção manual."
      ],
      "codeSnippet": "/* src/hooks/useToggleFavoriteArchetype.ts */\n\nexport const useToggleFavoriteArchetype = () => {\n  const queryClient = useQueryClient();\n  const { currentUser } = useAuth();\n\n  return useMutation({\n    mutationFn: (archetypeId: string) => {\n      return toggleFavoriteInFirestore(currentUser.uid, archetypeId);\n    },\n    onSuccess: () => {\n      // O PONTO CHAVE: Invalida a query do perfil do usuário para forçar a atualização.\n      queryClient.invalidateQueries({ queryKey: ['userProfile', currentUser?.uid] });\n    }\n  });\n};"
    }
  },
  "testingStrategy": {
    "title": "Estratégia de Testes e Mocking",
    "description": "Para testes de verificação de frontend (Playwright) e testes unitários, nós mockamos as dependências externas para garantir testes rápidos, confiáveis e independentes.",
    "approach": [
      {
        "layer": "Service Layer (src/services/firestore.ts)",
        "method": "As funções de serviço (`getUserProfile`, `updateDocument`) são modificadas para detectar um ambiente de teste. Em vez de chamar o Firestore, elas interagem com um objeto de banco de dados em memória (`mockDb`). Isso nos permite simular o comportamento do backend e controlar o estado dos dados durante os testes."
      },
      {
        "layer": "Auth Context (src/context/AuthContext.tsx)",
        "method": "O provedor de autenticação também é mockado para fornecer um usuário de teste consistente (`test-user`), evitando a necessidade de um fluxo de login real nos testes."
      }
    ]
  },
  "nextSteps": {
    "instruction": "Sua tarefa é aplicar este exato padrão para migrar as funcionalidades restantes do 'Portal Grimório'. Para cada nova funcionalidade (ex: 'Jornada Florescer', 'Compêndio Sincrético'), você deve:",
    "actions": [
      "1. Se necessário, criar um arquivo de dados estáticos em `src/data/`.",
      "2. Criar os hooks de `useQuery` necessários em `src/hooks/` para buscar os dados da funcionalidade.",
      "3. Criar os hooks de `useMutation` em `src/hooks/` para qualquer ação que modifique os dados, implementando o padrão de invalidação em `onSuccess`.",
      "4. Adicionar as funções correspondentes na Camada de Serviço em `src/services/`.",
      "5. Construir a nova página da funcionalidade em `src/pages/`, utilizando os hooks criados.",
      "6. Garantir que a estratégia de mocking seja estendida para suportar os novos serviços e dados nos testes."
    ]
  }
}